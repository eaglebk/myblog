{
  "id": "rust-vec-01",
  "topic": "Vec — динамический массив",
  "timeLimitSec": 400,
  "questions": [
    {
      "id": "q1",
      "title": "Что произойдёт при выполнении кода?",
      "code": "let crew = vec![\"Алиса\", \"Борис\"];\nprintln!(\"{}\", crew[10]);",
      "options": [
        "Напечатает пустую строку",
        "Вернёт None",
        "Программа упадёт с паникой",
        "Автоматически расширит вектор"
      ],
      "correctIndex": 2,
      "explanation": "Индекс 10 вне диапазона. Безопасный доступ — через .get(10)."
    },
    {
      "id": "q2",
      "title": "Как создать пустой вектор строк?",
      "options": [
        "Vec::new()",
        "vec!()",
        "Vec::<String>::new()",
        "Все варианты верны"
      ],
      "correctIndex": 3,
      "explanation": "Все варианты валидны (но тип должен быть выведен или указан)."
    },
    {
      "id": "q3",
      "title": "Что хранит Vec под капотом?",
      "options": [
        "Только список элементов",
        "Указатель на данные, длину и вместимость",
        "Только длину и данные",
        "Только вместимость"
      ],
      "correctIndex": 1,
      "explanation": "Vec хранит указатель на буфер, длину (len) и вместимость (capacity)."
    },
    {
      "id": "q4",
      "title": "Чем массив [T; N] отличается от Vec<T>?",
      "options": [
        "Массив фиксированного размера, Vec — динамический",
        "Vec не может хранить строки",
        "Массивы медленнее чем Vec",
        "Vec работает только с числами"
      ],
      "correctIndex": 0,
      "explanation": "Массивы в Rust имеют фиксированный размер, а Vec может расти и уменьшаться."
    },
    {
      "id": "q5",
      "title": "Что вернёт следующий код?",
      "code": "let crew = vec![\"Алиса\", \"Борис\"];\nprintln!(\"{:?}\", crew.get(10));",
      "options": ["Панику", "Some(\"\")", "None", "Компилятор выдаст ошибку"],
      "correctIndex": 2,
      "explanation": "Метод .get() возвращает Option. Для индекса вне диапазона это будет None."
    },
    {
      "id": "q6",
      "title": "Чем отличается crew[5] от crew.get(5)?",
      "options": [
        "Разницы нет, оба возвращают ссылку",
        "crew[5] может вызвать панику, crew.get(5) возвращает Option",
        "crew[5] всегда безопасен",
        "crew.get(5) расширяет вектор"
      ],
      "correctIndex": 1,
      "explanation": "`crew[5]` может паниковать, а `crew.get(5)` вернёт `None`, если элемента нет."
    },
    {
      "id": "q7",
      "title": "Почему этот код не компилируется?",
      "code": "let mut names = vec![String::from(\"Алиса\")];\nfor name in names.iter() {\n    *name = String::from(\"R-001 Алиса\");\n}",
      "options": [
        "iter() не поддерживает строки",
        "iter() возвращает &String, а не &mut String",
        "enumerate() нельзя использовать вместе с iter()",
        "Вектор по умолчанию неизменяемый"
      ],
      "correctIndex": 1,
      "explanation": "iter() возвращает только неизменяемые ссылки (&T). Чтобы изменять элементы, нужно использовать iter_mut()."
    },
    {
      "id": "q8",
      "title": "Какой тип имеет переменная name в этом цикле?",
      "code": "let mut names = vec![String::from(\"Алиса\")];\nfor name in names.iter_mut() {\n    println!(\"{}\", name);\n}",
      "options": ["String", "&String", "&mut String", "Option<&mut String>"],
      "correctIndex": 2,
      "explanation": "iter_mut() возвращает изменяемые ссылки, поэтому name имеет тип &mut String."
    },
    {
      "id": "q9",
      "title": "Что делает метод enumerate()?",
      "options": [
        "Превращает вектор в массив",
        "Добавляет индекс к каждому элементу при обходе",
        "Создаёт новый Vec<(usize, T)>",
        "Изменяет элементы по месту"
      ],
      "correctIndex": 1,
      "explanation": "enumerate() оборачивает итератор и добавляет индекс к каждому элементу."
    },
    {
      "id": "q10",
      "title": "Чем отличается push от extend?",
      "options": [
        "push добавляет один элемент, extend — целую коллекцию",
        "Разницы нет, это синонимы",
        "extend всегда копирует данные, а push — нет",
        "push требует &mut Vec, а extend — нет"
      ],
      "correctIndex": 0,
      "explanation": "push работает по одному элементу, а extend позволяет добавить сразу коллекцию или итератор."
    },
   {
      "id": "q11",
      "title": "Что произойдёт в этом коде?",
      "code": "let mut a = vec![1, 2];\nlet mut b = vec![3, 4];\na.append(&mut b);\nprintln!(\"{:?} {:?}\", a, b);",
      "options": [
        "[1, 2] [3, 4]",
        "[1, 2, 3, 4] []",
        "[1, 2, 3, 4] [3, 4]",
        "Ошибка компиляции"
      ],
      "correctIndex": 1,
      "explanation": "append перемещает элементы из b в a. После этого b очищается, поэтому результат: [1, 2, 3, 4] []."
    },
    {
      "id": "q12",
      "title": "Что делает метод with_capacity(n)?",
      "options": [
        "Создаёт вектор длиной n",
        "Резервирует место для n элементов, но оставляет длину равной 0",
        "Создаёт массив фиксированного размера",
        "Всегда удваивает вместимость"
      ],
      "correctIndex": 1,
      "explanation": "with_capacity(n) создаёт пустой вектор: len = 0, capacity = n."
    },
    {
      "id": "q13",
      "title": "Почему загрузка в Vec через push может работать медленнее?",
      "options": [
        "Каждый push требует вызова format!",
        "При переполнении Vec приходится выделять новый блок памяти и копировать элементы",
        "push всегда компилируется медленнее чем extend",
        "Vec не поддерживает большие коллекции"
      ],
      "correctIndex": 1,
      "explanation": "При переполнении capacity Vec делает реаллокацию: выделяет новый блок памяти и копирует туда все элементы."
    },
    {
      "id": "q14",
      "title": "Что делает метод truncate(n)?",
      "options": [
        "Убирает все элементы",
        "Оставляет только первые n элементов",
        "Удаляет элементы с начала",
        "Всегда очищает вектор"
      ],
      "correctIndex": 1,
      "explanation": "truncate(n) обрезает вектор, оставляя только первые n элементов."
    },
    {
      "id": "q15",
      "title": "Чем remove(0) хуже, чем drain(0..1) для больших буферов?",
      "options": [
        "remove(0) не работает с векторами",
        "remove(0) сдвигает все элементы, drain может убрать сразу диапазон",
        "Разницы нет",
        "drain всегда медленнее"
      ],
      "correctIndex": 1,
      "explanation": "remove(0) сдвигает все элементы влево. drain эффективнее, особенно если нужно удалить сразу несколько."
    },
     {
      "id": "q16",
      "title": "Как оставить в векторе только последние N элементов при росте?",
      "options": [
        "Через truncate(N)",
        "Через drain(0..len-N)",
        "Через remove(len-N)",
        "Через get(N)"
      ],
      "correctIndex": 1,
      "explanation": "Самый удобный способ — drain(0..len-N): он удаляет лишние элементы в начале, оставляя последние N."
    },
     {
      "id": "q17",
      "title": "Почему буфер с push без удаления не подходит для телеметрии?",
      "options": [
        "push не работает для чисел",
        "Буфер будет расти бесконечно и съест всю память",
        "push автоматически удаляет старые значения",
        "Vec ограничен максимум 100 элементами"
      ],
      "correctIndex": 1,
      "explanation": "Если только добавлять новые элементы через push, вектор будет расти без ограничений и рано или поздно исчерпает память."
    }
  ]
}
